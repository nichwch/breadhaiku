{"ast":null,"code":"'use strict';\n\nvar pluralize = require('pluralize');\n\nvar normalize = require('normalize-strings');\n\nvar problematic = require('./problematic.json');\n\nmodule.exports = syllables;\nvar own = {}.hasOwnProperty; // Two expressions of occurrences which normally would be counted as two\n// syllables, but should be counted as one.\n\nvar EXPRESSION_MONOSYLLABIC_ONE = new RegExp(['cia(?:l|$)', 'tia', 'cius', 'cious', '[^aeiou]giu', '[aeiouy][^aeiouy]ion', 'iou', 'sia$', 'eous$', '[oa]gue$', '.[^aeiuoycgltdb]{2,}ed$', '.ely$', '^jua', 'uai', 'eau', '^busi$', '(?:[aeiouy](?:' + ['[bcfgklmnprsvwxyz]', 'ch', 'dg', 'g[hn]', 'lch', 'l[lv]', 'mm', 'nch', 'n[cgn]', 'r[bcnsv]', 'squ', 's[chkls]', 'th'].join('|') + ')ed$)', '(?:[aeiouy](?:' + ['[bdfklmnprstvy]', 'ch', 'g[hn]', 'lch', 'l[lv]', 'mm', 'nch', 'nn', 'r[nsv]', 'squ', 's[cklst]', 'th'].join('|') + ')es$)'].join('|'), 'g');\nvar EXPRESSION_MONOSYLLABIC_TWO = new RegExp('[aeiouy](?:' + ['[bcdfgklmnprstvyz]', 'ch', 'dg', 'g[hn]', 'l[lv]', 'mm', 'n[cgn]', 'r[cnsv]', 'squ', 's[cklst]', 'th'].join('|') + ')e$', 'g'); // Four expression of occurrences which normally would be counted as one\n// syllable, but should be counted as two.\n\nvar EXPRESSION_DOUBLE_SYLLABIC_ONE = new RegExp('(?:' + ['([^aeiouy])\\\\1l', '[^aeiouy]ie(?:r|s?t)', '[aeiouym]bl', 'eo', 'ism', 'asm', 'thm', 'dnt', 'snt', 'uity', 'dea', 'gean', 'oa', 'ua', 'react?', 'orbed', // Cancel `'.[^aeiuoycgltdb]{2,}ed$',`\n'eings?', '[aeiouy]sh?e[rs]'].join('|') + ')$', 'g');\nvar EXPRESSION_DOUBLE_SYLLABIC_TWO = new RegExp(['[^gq]ua[^auieo]', '[aeiou]{3}', '^(?:ia|mc|coa[dglx].)', '^re(app|es|im|us)'].join('|'), 'g');\nvar EXPRESSION_DOUBLE_SYLLABIC_THREE = new RegExp(['[^aeiou]y[ae]', '[^l]lien', 'riet', 'dien', 'iu', 'io', 'ii', 'uen', 'real', 'iell', 'eo[^aeiou]', '[aeiou]y[aeiou]'].join('|'), 'g');\nvar EXPRESSION_DOUBLE_SYLLABIC_FOUR = /[^s]ia/; // Expression to match single syllable pre- and suffixes.\n\nvar EXPRESSION_SINGLE = new RegExp(['^(?:' + ['un', 'fore', 'ware', 'none?', 'out', 'post', 'sub', 'pre', 'pro', 'dis', 'side'].join('|') + ')', '(?:' + ['ly', 'less', 'some', 'ful', 'ers?', 'ness', 'cians?', 'ments?', 'ettes?', 'villes?', 'ships?', 'sides?', 'ports?', 'shires?', 'tion(?:ed|s)?'].join('|') + ')$'].join('|'), 'g'); // Expression to match double syllable pre- and suffixes.\n\nvar EXPRESSION_DOUBLE = new RegExp(['^' + '(?:' + ['above', 'anti', 'ante', 'counter', 'hyper', 'afore', 'agri', 'infra', 'intra', 'inter', 'over', 'semi', 'ultra', 'under', 'extra', 'dia', 'micro', 'mega', 'kilo', 'pico', 'nano', 'macro'].join('|') + ')', '(?:' + ['fully', 'berry', 'woman', 'women', 'edly'].join('|') + ')$'].join('|'), 'g'); // Expression to match triple syllable suffixes.\n\nvar EXPRESSION_TRIPLE = /(ology|ologist|onomy|onomist)$/g; // Expression to split on word boundaries.\n\nvar SPLIT = /\\b/g; // Expression to merge elision.\n\nvar APOSTROPHE = /['â€™]/g; // Expression to remove non-alphabetic characters from a given value.\n\nvar EXPRESSION_NONALPHABETIC = /[^a-z]/g; // Wrapper to support multiple word-parts (GH-11).\n\nfunction syllables(value) {\n  var values = normalize(String(value)).toLowerCase().replace(APOSTROPHE, '').split(SPLIT);\n  var length = values.length;\n  var index = -1;\n  var total = 0;\n\n  while (++index < length) {\n    total += syllable(values[index].replace(EXPRESSION_NONALPHABETIC, ''));\n  }\n\n  return total;\n} // Get syllables in a given value.\n\n\nfunction syllable(value) {\n  var count = 0;\n  var index;\n  var length;\n  var singular;\n  var parts;\n  var addOne;\n  var subtractOne;\n\n  if (value.length === 0) {\n    return count;\n  } // Return early when possible.\n\n\n  if (value.length < 3) {\n    return 1;\n  } // If `value` is a hard to count, it might be in `problematic`.\n\n\n  if (own.call(problematic, value)) {\n    return problematic[value];\n  } // Additionally, the singular word might be in `problematic`.\n\n\n  singular = pluralize(value, 1);\n\n  if (own.call(problematic, singular)) {\n    return problematic[singular];\n  }\n\n  addOne = returnFactory(1);\n  subtractOne = returnFactory(-1); // Count some prefixes and suffixes, and remove their matched ranges.\n\n  value = value.replace(EXPRESSION_TRIPLE, countFactory(3)).replace(EXPRESSION_DOUBLE, countFactory(2)).replace(EXPRESSION_SINGLE, countFactory(1)); // Count multiple consonants.\n\n  parts = value.split(/[^aeiouy]+/);\n  index = -1;\n  length = parts.length;\n\n  while (++index < length) {\n    if (parts[index] !== '') {\n      count++;\n    }\n  } // Subtract one for occurrences which should be counted as one (but are\n  // counted as two).\n\n\n  value.replace(EXPRESSION_MONOSYLLABIC_ONE, subtractOne).replace(EXPRESSION_MONOSYLLABIC_TWO, subtractOne); // Add one for occurrences which should be counted as two (but are counted as\n  // one).\n\n  value.replace(EXPRESSION_DOUBLE_SYLLABIC_ONE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_TWO, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_THREE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_FOUR, addOne); // Make sure at least on is returned.\n\n  return count || 1; // Define scoped counters, to be used in `String#replace()` calls.\n  // The scoped counter removes the matched value from the input.\n\n  function countFactory(addition) {\n    return counter;\n\n    function counter() {\n      count += addition;\n      return '';\n    }\n  } // Define scoped counters, to be used in `String#replace()` calls.\n  // The scoped counter does not remove the matched value from the input.\n\n\n  function returnFactory(addition) {\n    return returner;\n\n    function returner($0) {\n      count += addition;\n      return $0;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}